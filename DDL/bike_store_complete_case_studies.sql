/*
Here are some complex business use cases that involve advanced SQL techniques, including joins, window functions, subqueries, and CTEs,  to perform end-to-end analysis in Snowflake. 

These queries provide end-to-end analyses of different aspects of the business, such as customer segmentation, product sales trends, and employee performance, using Snowflake’s advanced SQL features. 

Each use case is crafted based on the relationships and data provided by the tables you’ve shared.

Each of these queries provides deep insights across different facets of the business by using Snowflake SQL features to analyze data comprehensively. 

*/

-- 1. Top-Selling Products by Category and Year
-- Problem: Identify the top-selling product in each category for each year, based on the total revenue generated from sales.

-- Solution: This query uses window functions and joins to calculate the top-selling products for each category and year.


WITH category_sales AS (
    SELECT
        p.category_id,
        c.category_name,
        p.product_id,
        p.product_name,
        p.model_year,
        SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS total_revenue
    FROM
        production.products p
    JOIN
        production.categories c ON p.category_id = c.category_id
    JOIN
        sales.order_items oi ON p.product_id = oi.product_id
    JOIN
        sales.orders o ON oi.order_id = o.order_id
    GROUP BY
        p.category_id, c.category_name, p.product_id, p.product_name, p.model_year
),
ranked_sales AS (
    SELECT
        category_id,
        category_name,
        product_id,
        product_name,
        model_year,
        total_revenue,
        RANK() OVER (PARTITION BY category_id, model_year ORDER BY total_revenue DESC) AS revenue_rank
    FROM
        category_sales
)
SELECT
    category_id,
    category_name,
    product_id,
    product_name,
    model_year,
    total_revenue
FROM
    ranked_sales
WHERE
    revenue_rank = 1
ORDER BY
    category_id, model_year;

    
-- 2. Customer Lifetime Value Analysis
-- Problem: Calculate the lifetime value of each customer based on their order history, where lifetime value is the total revenue generated by each customer. 
-- Identify customers with the highest lifetime value.

-- Solution: This solution involves aggregating order values by customer and ranking them.

WITH customer_revenue AS (
    SELECT
        o.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS lifetime_value
    FROM
        sales.orders o
    JOIN
        sales.order_items oi ON o.order_id = oi.order_id
    JOIN
        sales.customers c ON o.customer_id = c.customer_id
    GROUP BY
        o.customer_id, c.first_name, c.last_name
)
SELECT
    customer_id,
    customer_name,
    lifetime_value,
    RANK() OVER (ORDER BY lifetime_value DESC) AS lifetime_rank
FROM
    customer_revenue
ORDER BY
    lifetime_value DESC;

    
-- 3. Monthly Sales Growth per Store
-- Problem: Calculate the month-over-month growth in total sales for each store, allowing the business to analyze performance trends over time.

-- Solution: Using window functions and CTEs to calculate month-over-month sales growth for each store.

WITH monthly_sales AS (
    SELECT
        s.store_id,
        s.store_name,
        YEAR(o.order_date) AS sales_year,
        MONTH(o.order_date) AS sales_month,
        SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS total_sales
    FROM
        sales.orders o
    JOIN
        sales.order_items oi ON o.order_id = oi.order_id
    JOIN
        sales.stores s ON o.store_id = s.store_id
    GROUP BY
        1,2,3,4
),
sales_growth AS (
    SELECT
        store_id,
        store_name,
        sales_year,
        sales_month,
        total_sales,
        LAG(total_sales) OVER (PARTITION BY store_id ORDER BY sales_year,sales_month) AS previous_month_sales,
        (total_sales - LAG(total_sales) OVER (PARTITION BY store_id ORDER BY sales_year,sales_month)) / NULLIF(LAG(total_sales) OVER (PARTITION BY store_id ORDER BY sales_year,sales_month), 0) * 100 AS month_over_month_growth
    FROM
        monthly_sales
)
SELECT
    store_id,
    store_name,
    sales_year,
    sales_month,
    ROUND(NVL(total_sales,0),0)AS TOT_SALES,
    ROUND(NVL(previous_month_sales,0),0) AS PREV_MNTH_SALES,
    ROUND(NVL(month_over_month_growth,0),0) AS MNTH_OVER_MNTH_GRWTH
FROM
    sales_growth
ORDER BY
    store_id, sales_year,sales_month;


-- 4. Employee Performance Based on Sales Completion
-- Problem: Identify top-performing staff members by calculating the total revenue they managed and the percentage of orders completed. Rank the staff members based on these metrics.

-- Solution: This query uses window functions and a CTE to calculate each staff member's performance in terms of completed orders and total revenue managed.

WITH staff_performance AS (
    SELECT
        st.staff_id,
        CONCAT(st.first_name, ' ', st.last_name) AS staff_name,
        COUNT(o.order_id) AS total_orders,
        SUM(CASE WHEN o.order_status = 4 THEN 1 ELSE 0 END) AS completed_orders,
        SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS total_revenue
    FROM
        sales.orders o
    JOIN
        sales.order_items oi ON o.order_id = oi.order_id
    JOIN
        sales.staffs st ON o.staff_id = st.staff_id
    GROUP BY
        st.staff_id, st.first_name, st.last_name
),
ranked_performance AS (
    SELECT
        staff_id,
        staff_name,
        total_orders,
        completed_orders,
        (completed_orders::FLOAT / NULLIF(total_orders, 0)) * 100 AS completion_rate,
        total_revenue,
        RANK() OVER (ORDER BY total_revenue DESC) AS revenue_rank
    FROM
        staff_performance
)
SELECT
    staff_id,
    staff_name,
    total_orders,
    completed_orders,
    completion_rate,
    total_revenue,
    revenue_rank
FROM
    ranked_performance
ORDER BY
    revenue_rank;

    
-- 5. Inventory Analysis for Product Stock Levels
-- Problem: Determine which stores are running low on stock for products, and suggest stores with higher stock levels nearby that can fulfill potential restocking needs.

-- Solution: Using joins, window functions, and filtering for low stock levels by product, with recommendations based on stock availability in nearby locations.

WITH stock_levels AS (
    SELECT
        p.product_id,
        p.product_name,
        s.store_id,
        s.store_name,
        st.quantity AS stock_quantity
    FROM
        production.products p
    JOIN
        production.stocks st ON p.product_id = st.product_id
    JOIN
        sales.stores s ON st.store_id = s.store_id
),
low_stock AS (
    SELECT
        product_id,
        product_name,
        store_id,
        store_name,
        stock_quantity
    FROM
        stock_levels
    WHERE
        stock_quantity < 10 -- Threshold for low stock
),
recommended_stores AS (
    SELECT
        ls.product_id,
        ls.product_name,
        ls.store_id AS low_stock_store_id,
        ls.store_name AS low_stock_store,
        hs.store_id AS recommended_store_id,
        hs.store_name AS recommended_store,
        hs.stock_quantity AS recommended_store_stock
    FROM
        low_stock ls
    JOIN
        stock_levels hs ON ls.product_id = hs.product_id AND hs.stock_quantity >= 10 -- Threshold for sufficient stock
    WHERE
        ls.store_id != hs.store_id -- Exclude the original store
)
SELECT
    product_id,
    product_name,
    low_stock_store_id,
    low_stock_store,
    recommended_store_id,
    recommended_store,
    recommended_store_stock
FROM
    recommended_stores
ORDER BY
    product_id, low_stock_store_id;

-- 6. Customer Order Recency, Frequency, and Monetary Value Analysis (RFM)
-- Problem: Classify customers based on Recency, Frequency, and Monetary (RFM) analysis to help in targeting high-value customers with marketing campaigns.

-- Recency: Days since the last purchase
-- Frequency: Total number of orders placed
-- Monetary: Total revenue generated by the customer
-- Solution: Using window functions, CTEs, and date calculations to create RFM segments for each customer.

WITH customer_orders AS (
    SELECT
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        MAX(o.order_date) AS last_order_date,
        COUNT(o.order_id) AS order_frequency,
        SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS total_spent
    FROM
        sales.customers c
    LEFT JOIN
        sales.orders o ON c.customer_id = o.customer_id
    LEFT JOIN
        sales.order_items oi ON o.order_id = oi.order_id
    GROUP BY
        c.customer_id, c.first_name, c.last_name
),
rfm AS (
    SELECT
        customer_id,
        customer_name,
        DATEDIFF('day', last_order_date, CURRENT_DATE) AS recency,
        order_frequency AS frequency,
        total_spent AS monetary_value,
        NTILE(4) OVER (ORDER BY DATEDIFF('day', last_order_date, CURRENT_DATE)) AS recency_rank,
        NTILE(4) OVER (ORDER BY order_frequency) AS frequency_rank,
        NTILE(4) OVER (ORDER BY total_spent) AS monetary_rank
    FROM
        customer_orders
)
SELECT
    customer_id,
    customer_name,
    recency,
    frequency,
    monetary_value,
    recency_rank,
    frequency_rank,
    monetary_rank,
    CASE
        WHEN recency_rank = 4 AND frequency_rank = 4 AND monetary_rank = 4 THEN 'High Value'
        WHEN recency_rank <= 2 AND frequency_rank <= 2 AND monetary_rank <= 2 THEN 'Low Value'
        ELSE 'Mid Value'
    END AS rfm_segment
FROM
    rfm
ORDER BY
    rfm_segment, customer_id;

-- OR USE BELOW PERCENT_RANK INSTEAD OF NTILE() AS NTILE() is not available in matillion

WITH customer_orders AS (
    SELECT
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        MAX(o.order_date) AS last_order_date,
        COUNT(o.order_id) AS order_frequency,
        SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS total_spent
    FROM
        sales.customers c
    LEFT JOIN
        sales.orders o ON c.customer_id = o.customer_id
    LEFT JOIN
        sales.order_items oi ON o.order_id = oi.order_id
    GROUP BY
        c.customer_id, c.first_name, c.last_name
),
rfm AS (
    SELECT
        customer_id,
        customer_name,
        DATEDIFF('day', last_order_date, CURRENT_DATE) AS recency,
        order_frequency AS frequency,
        total_spent AS monetary_value,
        PERCENT_RANK() OVER (ORDER BY DATEDIFF('day', last_order_date, CURRENT_DATE)) AS recency_percentile,
        PERCENT_RANK() OVER (ORDER BY order_frequency) AS frequency_percentile,
        PERCENT_RANK() OVER (ORDER BY total_spent) AS monetary_percentile
    FROM
        customer_orders
)
SELECT
    customer_id,
    customer_name,
    recency,
    frequency,
    monetary_value,
    -- Convert percentiles to ranks by segmenting into 4 groups
    CASE 
        WHEN recency_percentile >= 0.75 THEN 4
        WHEN recency_percentile >= 0.5 THEN 3
        WHEN recency_percentile >= 0.25 THEN 2
        ELSE 1
    END AS recency_rank,
    CASE 
        WHEN frequency_percentile >= 0.75 THEN 4
        WHEN frequency_percentile >= 0.5 THEN 3
        WHEN frequency_percentile >= 0.25 THEN 2
        ELSE 1
    END AS frequency_rank,
    CASE 
        WHEN monetary_percentile >= 0.75 THEN 4
        WHEN monetary_percentile >= 0.5 THEN 3
        WHEN monetary_percentile >= 0.25 THEN 2
        ELSE 1
    END AS monetary_rank,
    CASE
        WHEN recency_percentile >= 0.75 AND frequency_percentile >= 0.75 AND monetary_percentile >= 0.75 THEN 'High Value'
        WHEN recency_percentile < 0.25 AND frequency_percentile < 0.25 AND monetary_percentile < 0.25 THEN 'Low Value'
        ELSE 'Mid Value'
    END AS rfm_segment
FROM
    rfm
ORDER BY
    rfm_segment, customer_id;


--7. Identify Frequently Purchased Products Together (Market Basket Analysis)
-- Problem: Determine frequently co-purchased products to create product bundles or recommendations.

-- Solution: Using self-joins and aggregation to find products often bought together in the same order.

WITH product_pairs AS (
    SELECT
        oi1.product_id AS product_a,
        p1.product_name AS product_a_name,
        oi2.product_id AS product_b,
        p2.product_name AS product_b_name,
        COUNT(*) AS co_purchase_count
    FROM
        sales.order_items oi1
    JOIN
        sales.order_items oi2 ON oi1.order_id = oi2.order_id AND oi1.product_id < oi2.product_id
    JOIN
        production.products p1 ON oi1.product_id = p1.product_id
    JOIN
        production.products p2 ON oi2.product_id = p2.product_id
    GROUP BY
        oi1.product_id, p1.product_name, oi2.product_id, p2.product_name
    HAVING
        co_purchase_count > 10 -- Minimum threshold for frequent co-purchase
)
SELECT
    product_a_name,
    product_b_name,
    co_purchase_count
FROM
    product_pairs
ORDER BY
    co_purchase_count DESC;

--8. Inventory Turnover Rate per Product
--Problem: Calculate the turnover rate for each product to determine how quickly inventory is sold and restocked, which can help in inventory planning and supply chain optimization.

--Solution: This query uses sales and stock data to calculate turnover rates by comparing sales quantities to current inventory levels.


WITH product_sales AS (
    SELECT
        p.product_id,
        p.product_name,
        SUM(oi.quantity) AS total_quantity_sold
    FROM
        production.products p
    JOIN
        sales.order_items oi ON p.product_id = oi.product_id
    GROUP BY
        p.product_id, p.product_name
),
product_stock AS (
    SELECT
        p.product_id,
        p.product_name,
        SUM(st.quantity) AS total_stock
    FROM
        production.products p
    JOIN
        production.stocks st ON p.product_id = st.product_id
    GROUP BY
        p.product_id, p.product_name
)
SELECT
    ps.product_id,
    ps.product_name,
    ps.total_quantity_sold,
    ps.total_quantity_sold / NULLIF(ps.total_stock, 0) AS turnover_rate -- Turnover rate = quantity sold / stock
FROM
    product_sales ps
JOIN
    product_stock st ON ps.product_id = st.product_id
ORDER BY
    turnover_rate DESC;
    
--9. Average Order Fulfillment Time by Store
--Problem: Calculate the average time taken by each store to fulfill orders (from order placement to shipment) and identify stores with the longest and shortest fulfillment times.

--Solution: Using date calculations and window functions to analyze order fulfillment times.

WITH order_fulfillment AS (
    SELECT
        s.store_id,
        s.store_name,
        DATEDIFF('day', o.order_date, o.shipped_date) AS fulfillment_time
    FROM
        sales.orders o
    JOIN
        sales.stores s ON o.store_id = s.store_id
    WHERE
        o.order_status = 4 -- Completed orders
)
SELECT
    store_id,
    store_name,
    AVG(fulfillment_time) AS avg_fulfillment_time
FROM
    order_fulfillment
GROUP BY
    store_id, store_name
ORDER BY
    avg_fulfillment_time ASC;

-- 10. Top Staff Members by Revenue Generation and Customer Satisfaction
-- Problem: Identify the top-performing staff members based on total revenue generated and the percentage of orders completed without delays. This can help recognize employees who consistently deliver high performance and customer satisfaction.

-- Solution: Using window functions to calculate revenue and on-time performance.

WITH staff_revenue AS (
    SELECT
        st.staff_id,
        CONCAT(st.first_name, ' ', st.last_name) AS staff_name,
        SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS total_revenue,
        SUM(CASE WHEN o.order_date <= o.shipped_date THEN 1 ELSE 0 END) / COUNT(o.order_id) * 100 AS on_time_percentage
    FROM
        sales.staffs st
    JOIN
        sales.orders o ON st.staff_id = o.staff_id
    JOIN
        sales.order_items oi ON o.order_id = oi.order_id
    WHERE
        o.order_status = 4 -- Completed orders
    GROUP BY
        st.staff_id, st.first_name, st.last_name
),
ranked_staff AS (
    SELECT
        staff_id,
        staff_name,
        total_revenue,
        on_time_percentage,
        RANK() OVER (ORDER BY total_revenue DESC) AS revenue_rank,
        RANK() OVER (ORDER BY on_time_percentage DESC) AS performance_rank
    FROM
        staff_revenue
)
SELECT
    staff_id,
    staff_name,
    total_revenue,
    on_time_percentage,
    revenue_rank,
    performance_rank
FROM
    ranked_staff
ORDER BY
    revenue_rank, performance_rank;

-- 11. Customer Retention Rate Over Time
-- Problem: Calculate the customer retention rate for each month by checking which customers have placed at least one order in consecutive months. This can help in understanding customer loyalty.

-- Solution: Using CTEs and window functions to find the retention rate.

WITH monthly_customers AS (
    SELECT
        o.customer_id,
        DATE_TRUNC('month', o.order_date) AS order_month
    FROM
        sales.orders o
    GROUP BY
        o.customer_id, DATE_TRUNC('month', o.order_date)
),
retained_customers AS (
    SELECT
        mc.customer_id,
        mc.order_month,
        LAG(mc.order_month) OVER (PARTITION BY mc.customer_id ORDER BY mc.order_month) AS previous_month
    FROM
        monthly_customers mc
)
SELECT
    order_month,
    COUNT(DISTINCT customer_id) AS total_customers,
    COUNT(DISTINCT CASE WHEN DATEADD('month', 1, previous_month) = order_month THEN customer_id END) AS retained_customers,
    (COUNT(DISTINCT CASE WHEN DATEADD('month', 1, previous_month) = order_month THEN customer_id END) * 100.0) / NULLIF(COUNT(DISTINCT customer_id), 0) AS retention_rate
FROM
    retained_customers
GROUP BY
    order_month
ORDER BY
    order_month;    
